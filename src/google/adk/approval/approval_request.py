
"""Defines data structures for representing approval requests, challenges, and responses.

This module includes:
- `ApprovalChallenge`: Represents a specific set of actions on resources that require approval.
- `ApprovalStatus`: (Currently unused internally but defined) Could represent the overall status of an approval.
- `ApprovalDenied`: An exception raised when an approval is explicitly denied.
- `ApprovalRequest`: Encapsulates a function call that is pending approval, along with the
  challenges that need to be met and the grantee.
- `ApprovalResponse`: Represents the user's or system's response to an approval request,
  typically containing a list of grants.
- `FunctionCallStatus`: Tracks the status (suspended, resumed, cancelled) of a function call
  that is subject to the approval workflow.
"""
from __future__ import annotations
from typing import Any, Literal

from google.genai.types import FunctionCall
from pydantic import BaseModel

from google.adk.approval.approval_grant import ApprovalAction, ApprovalActor, ApprovalEffect, ApprovalGrant, ApprovalResource


class ApprovalChallenge(BaseModel):
  """Represents a specific challenge within an approval request.

  A challenge details a set of actions on a list of resources that require
  explicit approval before they can be performed.
  """

  actions: list[ApprovalAction]
  """The list of actions (e.g., 'tool:files:read') that are being challenged."""
  resources: list[ApprovalResource]
  """The list of resources (e.g., 'tool:files:/data/my_file.txt') to which the actions apply."""


class ApprovalStatus(BaseModel):
  """Represents the overall status of an approval attempt (e.g., allowed, denied, challenged).

  Note: This class is defined but not actively used by the core approval handler in this version.
  It might be used for more complex approval UIs or logging.

  Attributes:
      effect: The overall effect of the approval status.
      challenges: A list of remaining or satisfied challenges.
  """
  effect: ApprovalEffect
  challenges: list[ApprovalChallenge]


class ApprovalDenied(ValueError):
  """Exception raised when an action is explicitly denied by an approval grant.

  Attributes:
      denied_challenges: A list of `ApprovalChallenge` objects that were denied.
  """

  def __init__(self, denied_challenges: list[ApprovalChallenge]):
    """Initializes the ApprovalDenied exception.

    Args:
        denied_challenges: The list of challenges that resulted in the denial.
    """
    super().__init__()
    self.denied_challenges = denied_challenges


class ApprovalRequest(BaseModel):
  """Represents a request for approval for a specific function call.

  This is typically generated by the `ApprovalHandler` when a tool call requires
  permissions that are not yet granted.

  Attributes:
      function_call: The `FunctionCall` that triggered this approval request.
      challenges: A list of `ApprovalChallenge` objects detailing what needs to be approved.
      grantee: The `ApprovalActor` (typically a tool) for whom the approval is requested.
  """
  function_call: FunctionCall
  challenges: list[ApprovalChallenge]
  grantee: ApprovalActor
  """The actor (typically a tool identified by its function call ID) for whom the approval is being sought."""


class ApprovalResponse(BaseModel):
  """Represents a response to an `ApprovalRequest`, usually containing new grants.

  This is typically sent by the user or an automated system to grant or deny
  the permissions requested in an `ApprovalRequest`.

  Attributes:
      grants: A list of `ApprovalGrant` objects resulting from the approval decision.
  """
  grants: list[ApprovalGrant]


class FunctionCallStatus(BaseModel):
  """Tracks the status and sequence of a function call within the approval workflow.

  When a function call requires approval, it is marked as "suspended". Once approval
  is granted (or if it's determined no approval is needed), it's "resumed".
  If denied, it's "cancelled". The sequence helps in ordering multiple status updates
  for the same function call if needed, though typically only the latest status is relevant.

  Attributes:
      function_call: The `FunctionCall` whose status is being tracked.
      status: The current approval-related status of the function call.
      sequence: A monotonically increasing number to order status updates.
  """
  function_call: FunctionCall
  status: Literal["suspended", "resumed", "cancelled"]
  sequence: int

  @classmethod
  def get_next_sequence(cls, function_call_statuses: list[dict[str, Any]]) -> int:
    """Calculates the next sequence number based on existing statuses.

    Args:
        function_call_statuses: A list of dictionaries, where each dictionary
                                  represents a serialized `FunctionCallStatus`.

    Returns:
        The next available sequence number (max existing sequence + 1).
    """
    return (
        max(
            [
                cls.model_validate(fcs_dict).sequence
                for fcs_dict in function_call_statuses
            ],
            default=0,
        )
        + 1
    )

  @classmethod
  def update_status(
      cls,
      function_call_statuses: list[dict[str, Any]],
      function_call: FunctionCall,
      status: Literal["suspended", "resumed", "cancelled"],
  ) -> list[dict[str, Any]]:
    """Updates the status list for a given function call.

    Removes any existing status for the specified `function_call` and adds a new
    `FunctionCallStatus` with the given `status` and the next sequence number.

    Args:
        function_call_statuses: The current list of serialized `FunctionCallStatus` objects.
        function_call: The `FunctionCall` to update.
        status: The new status for the function call.

    Returns:
        A new list of serialized `FunctionCallStatus` objects with the update applied.
    """
    return [
        fcs_dict
        for fcs_dict in function_call_statuses
        if cls.model_validate(fcs_dict).function_call != function_call
    ] + [
        cls(
            function_call=function_call,
            status=status,
            sequence=cls.get_next_sequence(function_call_statuses),
        ).model_dump(mode="json")
    ]
